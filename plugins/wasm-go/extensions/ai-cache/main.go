// File generated by hgctl. Modify as required.
// See: https://higress.io/zh-cn/docs/user/wasm-go#2-%E7%BC%96%E5%86%99-maingo-%E6%96%87%E4%BB%B6

package main

import (
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/alibaba/higress/plugins/wasm-go/extensions/ai-cache/embedding"
	"github.com/alibaba/higress/plugins/wasm-go/extensions/ai-cache/store"

	"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types"
	"github.com/tidwall/gjson"
	"github.com/tidwall/resp"
)

const (
	CacheClientContextKey    = "cacheClient"
	EmbeddingContextKey      = "embedding"
	CacheKeyContextKey       = "cacheKey"
	CacheContentContextKey   = "cacheContent"
	PartialMessageContextKey = "partialMessage"
	ToolCallsContextKey      = "toolCalls"
	StreamContextKey         = "stream"
	DefaultCacheKeyPrefix    = "higress-ai-cache:"
)

func main() {
	wrapper.SetCtx(
		"cache-tianchi",
		wrapper.ParseConfigBy(parseConfig),
		wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),
		wrapper.ProcessRequestBodyBy(onHttpRequestBody),
		wrapper.ProcessResponseHeadersBy(onHttpResponseHeaders),
		wrapper.ProcessStreamingResponseBodyBy(onHttpResponseBody),
	)
}

// @Name ai-cache
// @Category protocol
// @Phase AUTHN
// @Priority 10
// @Title zh-CN AI Cache
// @Description zh-CN 大模型结果缓存
// @IconUrl
// @Version 0.1.0
//
// @Contact.name johnlanni
// @Contact.url
// @Contact.email
//
// @Example
// redis:
//   serviceName: my-redis.dns
//   timeout: 2000
// cacheKeyFrom:
//   requestBody: "messages.@reverse.0.content"
// cacheValueFrom:
//   responseBody: "choices.0.message.content"
// cacheStreamValueFrom:
//   responseBody: "choices.0.delta.content"
// returnResponseTemplate: |
//   {"id":"from-cache","choices":[{"index":0,"message":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}
// returnStreamResponseTemplate: |
//   data:{"id":"from-cache","choices":[{"index":0,"delta":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}
//
//   data:[DONE]
//
// @End

type KVExtractor struct {
	// @Title zh-CN 从请求 Body 中基于 [GJSON PATH](https://github.com/tidwall/gjson/blob/master/SYNTAX.md) 语法提取字符串
	RequestBody string `required:"false" yaml:"requestBody" json:"requestBody"`
	// @Title zh-CN 从响应 Body 中基于 [GJSON PATH](https://github.com/tidwall/gjson/blob/master/SYNTAX.md) 语法提取字符串
	ResponseBody string `required:"false" yaml:"responseBody" json:"responseBody"`
}

type PluginConfig struct {
	// @Title zh-CN Redis 地址信息
	// @Description zh-CN 用于存储缓存结果的 Redis 地址
	StoreConfig store.StoreConfig `required:"true" yaml:"cache" json:"cache"`
	// @Title zh-CN 缓存 key 的来源
	// @Description zh-CN 往 redis 里存时，使用的 key 的提取方式
	CacheKeyFrom KVExtractor `required:"true" yaml:"cacheKeyFrom" json:"cacheKeyFrom"`
	// @Title zh-CN 缓存 value 的来源
	// @Description zh-CN 往 redis 里存时，使用的 value 的提取方式
	CacheValueFrom KVExtractor `required:"true" yaml:"cacheValueFrom" json:"cacheValueFrom"`
	// @Title zh-CN 流式响应下，缓存 value 的来源
	// @Description zh-CN 往 redis 里存时，使用的 value 的提取方式
	CacheStreamValueFrom KVExtractor `required:"true" yaml:"cacheStreamValueFrom" json:"cacheStreamValueFrom"`
	// @Title zh-CN 返回 HTTP 响应的模版
	// @Description zh-CN 用 %s 标记需要被 cache value 替换的部分
	ReturnResponseTemplate string `required:"true" yaml:"returnResponseTemplate" json:"returnResponseTemplate"`
	// @Title zh-CN 返回流式 HTTP 响应的模版
	// @Description zh-CN 用 %s 标记需要被 cache value 替换的部分
	ReturnStreamResponseTemplate string `required:"true" yaml:"returnStreamResponseTemplate" json:"returnStreamResponseTemplate"`
	// @Title zh-CN 缓存的过期时间
	// @Description zh-CN 单位是秒，默认值为0，即永不过期
	CacheTTL int `required:"false" yaml:"cacheTTL" json:"cacheTTL"`
	// @Title zh-CN Redis缓存Key的前缀
	// @Description zh-CN 默认值是"higress-ai-cache:"
	CacheKeyPrefix string `required:"false" yaml:"cacheKeyPrefix" json:"cacheKeyPrefix"`

	IndexConfig store.Index `required:"true" yaml:"index" json:"index"`

	EmbeddingProviderConfig embedding.ProviderConfig `required:"true" yaml:"provider" json:"provider"`

	Threshold string `required:"false" yaml:"threshold" json:"threshold"`
}

func parseConfig(json gjson.Result, c *PluginConfig, log wrapper.Log) error {
	log.Debugf("init config time: %s", time.Now().Format("2006-01-02 15:04:05"))
	c.StoreConfig.Type = json.Get("cache.type").String()
	if c.StoreConfig.Type == "" {
		return errors.New("cache type must not by empty")
	}
	c.StoreConfig.ServiceName = json.Get("cache.serviceName").String()
	if c.StoreConfig.ServiceName == "" {
		return errors.New("cache service name must not by empty")
	}
	c.StoreConfig.ServicePort = int(json.Get("cache.servicePort").Int())
	if c.StoreConfig.ServicePort == 0 {
		if strings.HasSuffix(c.StoreConfig.ServiceName, ".static") {
			// use default logic port which is 80 for static service
			c.StoreConfig.ServicePort = 80
		} else {
			return errors.New("cache service port must not by empty")
		}
	}
	c.StoreConfig.Username = json.Get("cache.username").String()
	c.StoreConfig.Password = json.Get("cache.password").String()
	c.StoreConfig.Timeout = int(json.Get("cache.timeout").Int())
	if c.StoreConfig.Timeout == 0 {
		c.StoreConfig.Timeout = 1000
	}
	c.CacheKeyFrom.RequestBody = json.Get("cacheKeyFrom.requestBody").String()
	if c.CacheKeyFrom.RequestBody == "" {
		c.CacheKeyFrom.RequestBody = "messages.@reverse.0.content"
	}
	c.CacheValueFrom.ResponseBody = json.Get("cacheValueFrom.responseBody").String()
	if c.CacheValueFrom.ResponseBody == "" {
		c.CacheValueFrom.ResponseBody = "choices.0.message.content"
	}
	c.CacheStreamValueFrom.ResponseBody = json.Get("cacheStreamValueFrom.responseBody").String()
	if c.CacheStreamValueFrom.ResponseBody == "" {
		c.CacheStreamValueFrom.ResponseBody = "choices.0.delta.content"
	}
	c.ReturnResponseTemplate = json.Get("returnResponseTemplate").String()
	if c.ReturnResponseTemplate == "" {
		c.ReturnResponseTemplate = `{"id":"from-cache","choices":[{"index":0,"message":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}`
	}
	c.ReturnStreamResponseTemplate = json.Get("returnStreamResponseTemplate").String()
	if c.ReturnStreamResponseTemplate == "" {
		c.ReturnStreamResponseTemplate = `data:{"id":"from-cache","choices":[{"index":0,"delta":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}` + "\n\ndata:[DONE]\n\n"
	}
	c.CacheKeyPrefix = json.Get("cacheKeyPrefix").String()
	if c.CacheKeyPrefix == "" {
		c.CacheKeyPrefix = DefaultCacheKeyPrefix
	}

	// embedding provider config
	c.EmbeddingProviderConfig.Model = json.Get("provider.model").String()
	if c.EmbeddingProviderConfig.Model == "" {
		return errors.New("embedding model is required")
	}
	c.EmbeddingProviderConfig.ApiToken = json.Get("provider.apiToken").String()
	c.EmbeddingProviderConfig.Typ = json.Get("provider.type").String()

	// index config
	c.IndexConfig.Name = json.Get("index.name").String()
	if c.IndexConfig.Name == "" {
		return errors.New("index name is required")
	}
	c.IndexConfig.DataType = json.Get("index.dataType").String()
	if c.IndexConfig.DataType == "" {
		c.IndexConfig.DataType = "FLOAT32"
	}
	c.IndexConfig.Dim = uint32(json.Get("index.dim").Int())
	if c.IndexConfig.Dim == 0 {
		return errors.New("index dim is required")
	}
	c.IndexConfig.Typ = json.Get("index.typ").String()
	if c.IndexConfig.Typ == "" {
		c.IndexConfig.Typ = "FLAT"
	}
	c.IndexConfig.DistanceMethod = json.Get("index.distanceMethod").String()
	if c.IndexConfig.DistanceMethod == "" {
		c.IndexConfig.DistanceMethod = "COSINE"
	}

	c.Threshold = json.Get("threshold").String()

	log.Debugf("init config success")
	return nil
}

func onHttpRequestHeaders(ctx wrapper.HttpContext, config PluginConfig, log wrapper.Log) types.Action {
	log.Debugf("handle request headers")
	contentType, _ := proxywasm.GetHttpRequestHeader("content-type")
	// The request does not have a body.
	if contentType == "" {
		return types.ActionContinue
	}
	if !strings.Contains(contentType, "application/json") {
		log.Warnf("content is not json, can't process:%s", contentType)
		ctx.DontReadRequestBody()
		return types.ActionContinue
	}
	proxywasm.RemoveHttpRequestHeader("Accept-Encoding")
	// The request has a body and requires delaying the header transmission until a cache miss occurs,
	// at which point the header should be sent.
	return types.HeaderStopIteration
}

func TrimQuote(source string) string {
	return strings.Trim(source, `"`)
}

func onHttpRequestBody(ctx wrapper.HttpContext, config PluginConfig, body []byte, log wrapper.Log) types.Action {
	log.Debugf("handle request body")
	bodyJson := gjson.ParseBytes(body)

	log.Debugf("bodyJson:%s", bodyJson)
	key := TrimQuote(bodyJson.Get(config.CacheKeyFrom.RequestBody).Raw)
	if key == "" {
		log.Debug("parse key from request body failed")
		return types.ActionContinue
	}
	ctx.SetContext(CacheKeyContextKey, key)
	provider, err := embedding.CreateProvider(config.EmbeddingProviderConfig, log)
	if err != nil {
		log.Errorf("create embedding provider failed, error:%v", err)
		return types.ActionContinue
	}
	cache, err := store.CreateStore(config.StoreConfig)
	ctx.SetContext(CacheClientContextKey, cache)
	if err != nil {
		log.Errorf("create cache store failed, error:%v", err)
		return types.ActionContinue
	}

	afterGeyKey := func(response resp.Value) {
		log.Debugf("afterGetKey start")
		searchResponse, err := cache.ParseSearchResponse(response)
		if err != nil {
			log.Errorf("parse cache get key response failed, error:%v", err)
			proxywasm.ResumeHttpRequest()
		}
		if searchResponse.Raw != key {
			vector := store.Vector{
				Content: ctx.GetContext(EmbeddingContextKey).([]float32),
				Raw:     key,
				Answer:  searchResponse.Answer,
			}
			_, err = cache.StoreVector(vector, config.IndexConfig.Name)
			if err != nil {
				log.Errorf("store request: %s vector failed, error:%v", key, err)
			}
		}
		log.Debugf("searchResponse raw: %v, searchResponse answer: %v", searchResponse.Raw, searchResponse.Answer)
		log.Debugf("return response cache value: %v", fmt.Sprintf(config.ReturnResponseTemplate, searchResponse.Answer))
		proxywasm.SendHttpResponse(200, [][2]string{{"content-type", "application/json; charset=utf-8"}}, []byte(fmt.Sprintf(config.ReturnResponseTemplate, searchResponse.Answer)), -1)
	}

	// embedding search 的回调函数，判断向量距离，存储相似问题，返回相似回答
	afterEmbeddingSearch := func(response resp.Value) {
		log.Debugf("afterEmbeddingSearch start")
		getKeyResponse, err := cache.ParseGetKeyResponse(response)
		if err != nil {
			log.Errorf("parse cache embedding search response failed, error: %v", err)
			proxywasm.ResumeHttpRequest()
		}
		float, err := strconv.ParseFloat(config.Threshold, 32)
		if err != nil {
			log.Errorf("parse threshold failed, error:%v", err)
			proxywasm.ResumeHttpRequest()
		}
		log.Debugf("key: %s, distance: %f", getKeyResponse.Key, getKeyResponse.Distance)
		if getKeyResponse.Distance < float32(float) {
			cache.GetKey(config.IndexConfig.Name, getKeyResponse.Key, afterGeyKey)
		} else {
			proxywasm.ResumeHttpRequest()
		}
	}

	// provider embedding 的回调函数，处理响应并调用 search
	afterEmbedding := func(statusCode int, responseHeaders http.Header, responseBody []byte) {
		log.Debugf("afterEmbedding start")
		emb, err := provider.ParseEmbeddingResponse(responseBody)
		if err != nil {
			log.Errorf("parse embedding response failed, error:%v", err)
			proxywasm.ResumeHttpRequest()
		}
		ctx.SetContext(EmbeddingContextKey, emb)
		log.Debugf("start search vector: %s", config.IndexConfig.Name)
		err = cache.SearchVector(config.IndexConfig.Name, 1, emb, afterEmbeddingSearch)
		if err != nil {
			log.Errorf("cache search question: %s failed, embedding: %v error:%v", ctx.GetContext(CacheKeyContextKey).(string), emb, err)
			proxywasm.ResumeHttpRequest()
		}
	}

	// provider embedding 的回调函数，向量化问题
	err = provider.EmbeddingRequest(key, afterEmbedding)
	if err != nil {
		log.Errorf("request: %s embedding request failed, error:%v", key, err)
		return types.ActionContinue
	}

	return types.ActionPause
}

func processSSEMessage(ctx wrapper.HttpContext, config PluginConfig, sseMessage string, log wrapper.Log) string {
	subMessages := strings.Split(sseMessage, "\n")
	var message string
	for _, msg := range subMessages {
		if strings.HasPrefix(msg, "data:") {
			message = msg
			break
		}
	}
	if len(message) < 6 {
		log.Errorf("invalid message:%s", message)
		return ""
	}
	// skip the prefix "data:"
	bodyJson := message[5:]
	if gjson.Get(bodyJson, config.CacheStreamValueFrom.ResponseBody).Exists() {
		tempContentI := ctx.GetContext(CacheContentContextKey)
		if tempContentI == nil {
			content := TrimQuote(gjson.Get(bodyJson, config.CacheStreamValueFrom.ResponseBody).Raw)
			ctx.SetContext(CacheContentContextKey, content)
			return content
		}
		append := TrimQuote(gjson.Get(bodyJson, config.CacheStreamValueFrom.ResponseBody).Raw)
		content := tempContentI.(string) + append
		ctx.SetContext(CacheContentContextKey, content)
		return content
	} else if gjson.Get(bodyJson, "choices.0.delta.content.tool_calls").Exists() {
		// TODO: compatible with other providers
		ctx.SetContext(ToolCallsContextKey, struct{}{})
		return ""
	}
	log.Debugf("unknown message:%s", bodyJson)
	return ""
}

func onHttpResponseHeaders(ctx wrapper.HttpContext, config PluginConfig, log wrapper.Log) types.Action {
	contentType, _ := proxywasm.GetHttpResponseHeader("content-type")
	if strings.Contains(contentType, "text/event-stream") {
		ctx.SetContext(StreamContextKey, struct{}{})
	}
	return types.ActionContinue
}

func onHttpResponseBody(ctx wrapper.HttpContext, config PluginConfig, chunk []byte, isLastChunk bool, log wrapper.Log) []byte {
	if ctx.GetContext(ToolCallsContextKey) != nil {
		// we should not cache tool call result
		return chunk
	}
	keyI := ctx.GetContext(CacheKeyContextKey)
	if keyI == nil {
		return chunk
	}
	if !isLastChunk {
		stream := ctx.GetContext(StreamContextKey)
		if stream == nil {
			tempContentI := ctx.GetContext(CacheContentContextKey)
			if tempContentI == nil {
				ctx.SetContext(CacheContentContextKey, chunk)
				return chunk
			}
			tempContent := tempContentI.([]byte)
			tempContent = append(tempContent, chunk...)
			ctx.SetContext(CacheContentContextKey, tempContent)
		} else {
			var partialMessage []byte
			partialMessageI := ctx.GetContext(PartialMessageContextKey)
			if partialMessageI != nil {
				partialMessage = append(partialMessageI.([]byte), chunk...)
			} else {
				partialMessage = chunk
			}
			messages := strings.Split(string(partialMessage), "\n\n")
			for i, msg := range messages {
				if i < len(messages)-1 {
					// process complete message
					processSSEMessage(ctx, config, msg, log)
				}
			}
			if !strings.HasSuffix(string(partialMessage), "\n\n") {
				ctx.SetContext(PartialMessageContextKey, []byte(messages[len(messages)-1]))
			} else {
				ctx.SetContext(PartialMessageContextKey, nil)
			}
		}
		return chunk
	}
	// last chunk
	key := keyI.(string)
	stream := ctx.GetContext(StreamContextKey)
	var value string
	if stream == nil {
		var body []byte
		tempContentI := ctx.GetContext(CacheContentContextKey)
		if tempContentI != nil {
			body = append(tempContentI.([]byte), chunk...)
		} else {
			body = chunk
		}
		bodyJson := gjson.ParseBytes(body)
		log.Debugf("on response body:%s", body)
		value = TrimQuote(bodyJson.Get(config.CacheValueFrom.ResponseBody).Raw)
		log.Debugf("on response id: %s", bodyJson.Get("id").String())
		if value == "" {
			log.Warnf("parse value from response body failded, body:%s", body)
			return chunk
		}
	} else {
		if len(chunk) > 0 {
			var lastMessage []byte
			partialMessageI := ctx.GetContext(PartialMessageContextKey)
			if partialMessageI != nil {
				lastMessage = append(partialMessageI.([]byte), chunk...)
			} else {
				lastMessage = chunk
			}
			if !strings.HasSuffix(string(lastMessage), "\n\n") {
				log.Warnf("invalid lastMessage:%s", lastMessage)
				return chunk
			}
			// remove the last \n\n
			lastMessage = lastMessage[:len(lastMessage)-2]
			value = processSSEMessage(ctx, config, string(lastMessage), log)
		} else {
			tempContentI := ctx.GetContext(CacheContentContextKey)
			if tempContentI == nil {
				return chunk
			}
			value = tempContentI.(string)
		}
	}
	cache := ctx.GetContext(CacheClientContextKey).(store.Store)

	vec := store.Vector{
		Content: ctx.GetContext(EmbeddingContextKey).([]float32),
		Raw:     key,
		Answer:  value,
	}

	log.Debugf("on response stage store vector: %v", vec)
	_, err := cache.StoreVector(vec, config.IndexConfig.Name)
	if err != nil {
		log.Errorf("In response stage, store request: %s vector failed, error:%v", key, err)
	}
	return chunk
}
